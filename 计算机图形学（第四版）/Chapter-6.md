# 实现图元及属性的算法

设备级实现算法

## 1 画线算法

### 1.1 直线方程

直线得笛卡尔斜率截距方程：
$$
y=m*x+b \tag{6.1} 	
$$

$$
m=\frac{y_{end}-y_0}{x_{end}-x_0} \tag{6.2}
$$

$$
b=y_0-m*x_0 \tag{6.3}
$$

$$
\delta y=m*\delta x \tag{6.4}
$$

$$
\delta x=\frac {\delta y}{m} \tag{6.5}
$$



### 1.2 DDA算法

数字微分分析仪(digital differential analyzer, DDA)算法 （线段扫描转换算法）

基于$(6.4)$和$(6.5)$来计算$\delta x$或$\delta y$

以单位$x$间隔$(\delta x=1)$取样，逐个计算$y$，取整
$$
y_{k+1}=y_{k}+m \tag{6.6}
$$
斜率大于1得话，交换x和y的位置，以$(\delta y=1)$取样，顺序计算$x$，取整
$$
x_{k+1}=x_{k}+\frac {1}{m} \tag{6.7}
$$


优点：

1. 计算像素位置比直接使用直线方程$(6.1)$计算得速度更快



缺点：

1. 取整操作和浮点运算耗时，可将增量m和1/m分离成整数和小数部分

### 1.3 Bresenham画线算法

精确而有效的光栅生成算法
$$
y=m(x_k+1)+b \tag{6.8}
$$

$$
d_{lower}=y-y_k \tag{6.9}
$$

$$
d_{upper}=(y_k+1)-y\\
=y_k+1-m(x_k+1)-b \tag{6.10}
$$

则偏差值:
$$
d_{lower}-d_{upper}=2m(x_k+1)-2y_k+2b-1 \tag{6.11}
$$
重新安排画线算法可得第k步的决策参数$p_k$，从而可以仅使用整数进行计算
$$
p_k=\Delta x(d_{lower}-d_{upper})\\
=2\Delta y*x_k-2\Delta x*y_k+c \tag{6.12}
$$
参数$c$为一个常量:$2\Delta y+\Delta x(2b-1)$

$p_k<0$: 选择$y_k$

$p_k>0$:选择$y_{k+1}$

第k+1步$p_{k+1}$减去$p_k$：
$$
p_{k+1}-p_k=2\Delta y(x_{k+1}-x_k)-2 \Delta x(y_{k+1}-y_k)\\
x_{k+1}=x_k+1 \\
$$

$$
p_{k+1}=p_k+2\Delta y-2\Delta x(y_{k+1}-y_k) \tag{6.13}
$$

其中，$y_{k+1}-y_k$取值为0或1，取决于参数$p_k$的符号。



决策参数的递归计算从线段左端点开始的每个整数$x$的位置进行。起始像素位置$(x_0,y_0)$的第一个参数$p_0$通过方程$(6.12)$及$m=\Delta y/\Delta x$计算得出：
$$
p_0=2\Delta y - \Delta x \tag{6.14}
$$


#### 1.3.1 算法伪代码

$|m|<1$时：

1. 输入线段的两个端点，并将左端点存储在$(x_0,y_0)$中

2. 将$(x_0,y_0)$装入帧缓存，画出第一个点

3. 计算常量$\Delta x、\Delta y、2\Delta y、2\Delta y-2\Delta x$，并得到决策参数的第一个值：
   $$
   p_0=2\Delta y-\Delta x
   $$

4. 从$k=0$开始，在沿线段路径的每个$x_k$处，进行下列检测：

   如果$p_k<0$，下一点绘制$(x_k+1,y_k)$，并且
   $$
   p_{k+1}=p_k+2\Delta y
   $$
   否则，绘制$(x_k+1,y_{k}+1)$，并且
   $$
   p_{k+1}=p_k+2\Delta y-2\Delta x
   $$

5. 重复Step 4，共$\Delta x-1$次



## 2 并行画线算法

利用并行计算机，可通过将计算分割到可用的多个处理器中来得到线段的像素位置。

（重点考虑平衡可用处理器间的处理负载）

给定$n_p$个处理器，把线段分割成$n_p$个子段，并在每个子段中同时生成线段而建立起并行的Bresenham画线算法。


$$
\Delta x_p=\frac{\Delta x+n_p-1}{n_p} \tag{6.15}
$$
计算出第k分段的起始x的坐标为：
$$
x_k=x_0+k\Delta x_p  \tag{6.16}
$$
假设$\Delta x=15$且$n_p=4$，则分段的水平宽度为$4$，各分段的初始$x$为$x_0,x_0+4,x_0+8,x_0+12$。

分段$y$方向的变化$\Delta y_p$，可从线段斜率$m$和分段宽度$\Delta x_p$计算得出：
$$
\Delta y_p=m\Delta x_p \tag{6.17}
$$
那么第$k$分段的起始$y$坐标为：
$$
y_k=y_0+round(k\Delta y_p) \tag{6.18}
$$
第$k$分段起始处Bresenham算法的初始决策参数可得：
$$
p_k=(k\Delta x_p)(2\Delta y)-round(k\Delta y_p)(2\Delta x)+2\Delta y-\Delta x \tag{6.19}
$$

## 3 帧缓存值的装载

**帧缓存以行为主序线性存储**

实现线段和其他对象显示函数的最后一步工作：设定帧缓存的颜色值。

由于扫描转换算法以连续的单位间隔生成像素位置，因此扫描转换算法可使用增量方法在每一步高效地存取帧缓存。
$$
addr(x,y)=addr(0,0)+y(x_{max}+1)+x \tag{6.20}
$$
沿扫描线移动，像素$(x+1,y)$处的帧缓存地址可以根据位置$(x,y)$的地址偏移进行计算：
$$
addr(x+1,y)=addr(x,y)+1 \tag{6.21}
$$

## 4 圆生成算法

### 4.1 圆特性

$$
(x-x_c)^2+(y-y_c)^2=r^2 \tag{6.22}
$$

从而：
$$
y=y_c \pm \sqrt{r_2-(x_c-x)^2} \tag{6.23}
$$
计算量大。

### 4.2 中点圆算法

$$
f_{circ}(x,y)=x^2+y^2-r^2 \tag{6.24}
$$

$$
f_{circ}(x,y)
\begin{cases}
<0, (x,y)在圆周边界之内\\
=0, (x,y)在圆周边界之上\\
>0, (x,y)在圆周边界之外 \tag{6.25}
\end{cases}
$$

Step:

1. 输入圆半径r和圆心$(x_c,y_c)$，并得到圆周上的第一个点，
   $$
   (x_0,y_0)=(0,r)
   $$

2. 计算决策参数的初始值
   $$
   p_0=\frac{5}{4}-r
   $$

3. 在每个$x_k$位置，从$k=0$开始，完成下列测试：加入$p_k<0$，圆心在$(0,0)$的圆的下一个点为$(x_{k+1},y_k)$，并且
   $$
   p_{k+1}=p_k+2x_{k+1}+1
   $$
   否则，圆的下一个点是$(x_k+1,y_k-1)$，并且
   $$
   p_{k+1}=p_k+2x_{k+1}+1-2y_{k+1}
   $$
   其中$2x_{k+1}=2x_k+2$且$2y_{k+1}=2y_k-2$

4. 确定在其他七个八分圆中的对称点

5. 将每个计算出的像素位置$(x,y)$移动到圆心在$(x_c,y_c)$的圆路径上，并画坐标值：
   $$
   x=x+x_c,y=y+y_c
   $$

6. 重复3-5,直到$x \geq y$

## 5 椭圆生成算法

$$
f_{ellipse}(x,y)=r_y^2x^2+r_x^2y^2-r_x^2r_y^2 \tag{6.26}
$$


$$
f_{ellipse}(x,y)
\begin{cases}
<0,(x,y)在椭圆边界之内\\
=0,(x,y)在椭圆边界之上\\
>0,(x,y)在椭圆边界之外
\end{cases}

\tag{6.27}
$$
Step:

1. 输入$r_x、r_y$和椭圆中心$(x_c,y_c)$，并得到椭圆（中心在原点）上的第一个点，
   $$
   (x_0,y_0)=(0,r_y)
   $$

2. 计算区域1中决策参数的初始值
   $$
   p1_0=r_y^2-r_x^2r_y+\frac{1}{4}r_x^2
   $$

3. 在区域1中的每个$x_k$位置，从k=0开始，完成下列测试：假如$p1_k<0$，沿中心在$(0,0)$的椭圆的下一个点为$(x_{k+1},y_k)$，并且
   $$
   p1_{k+1}=p1_k+2r_y^2x_{k+1}+r_y^2
   $$
   否则，沿椭圆的下一个点为$(x_k+1,y_k-1)$，并且
   $$
   p1_{k+1}=p1_k+2r_y^2x_{k+1}-2r_x^2y_{k+1}+r_y^2
   $$
   其中
   $$
   2r_y^2x_{k+1}=2r_y^2x_k+2r_y^2,2r_x^2y_{k+1}=2r_x^2y_k-2r_x^2
   $$
   继续此步骤，直到$2r_y^2x \ge 2r_x^2 y$

4. 使用区域1中计算的最后点$(x_0,y_0)$来计算区域2中参数的初始值
   $$
   p2_0=r_y^2(x_9+\frac{1}{2})^2+r_x^2(y_0-1)^2-r_x^2r_y^2
   $$

5. 在区域2的每个$y_k$位置处，从k=0开始，完成下列测试：假如$p2_k>0$，沿中心为$(0,0)$的椭圆的下一个点为$(x_k,y_k-1)$，并且
   $$
   p2_{k+1}=p2_k-2r_x^2y_{k+1}+r_x^2
   $$
   否则，沿椭圆的下一个点位$(x_k+1,y_k-1)$，并且
   $$
   p2_{k+1}=p2_k+2r_y^2x_{k+1}-2r_x^2y_{k+1}+r_x^2
   $$
   使用与区域1中相同的x和y增量，继续此步骤计算，直到y=0

6. 确定其他三个象限中的对称点

7. 将计算出的每个像素位置$(x,y)$移到中心在$(x_c,y_c)$的椭圆轨迹上，并按坐标值绘制点：
   $$
   x=x+x_c, y=y+y_c
   $$

## 6 区域填充算法

### 6.1 规则区域填充

有序边表(sorted edge table)

活化边表(active edge list)

### 6.2 不规则区域填充

边界填充算法(boundary-fill algorithm)

> 边界以单一颜色指定，填充算法可逐个像素地向外处理，直到遇到边界颜色



从当前检测位置处理相邻像素地两种方法

1. 4-连通(4-connected)区域

   > 当前像素右面、左面、上面和下面的橡塑位置

2. 8-连通(8-connected)区域

   > 在4连通基础上再加旁边4个（想象象棋 田 ）

